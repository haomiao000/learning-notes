[读书随笔]《Operating Systems》

# 第一章 关于本书的对话

既然书中也在拉日常，那我也随便聊聊吧

撇去浮燥的生活方式，终于可以静下来做些自己真正想做的事，今天，2024年7月26日，就来开个新坑吧，本书名叫《Operating Systems》纯属冲浪时无意看到的一本书，本想去拜读一下CSAPP，突然被这本书吸引，就先他吧！

第一章没什么好说的就是（老外的一些奇怪的幽默对话）感兴趣可以自己看一下（我们直接来看第二章。
# 操作系统介绍

这部分提出了几个非常笼统的概念

- 虚拟化CPU
- 虚拟化内存

在日常计算机的使用中，我们可以很直观的感受到多个程序同时运行的场景，在我们的认知中，一个CPU同一时间只能处理一个程序，那么他是如何让我们在感官上感觉多个程序同时运行呢？事实上，在硬件的一些帮助下，操作系统负责提供这些假象，即拥有非常多CPU的假象，这样的虚拟化过程也是操作系统的核心特点之一。

当然，程序运行就需要资源，试想这样一个程序

```C
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include "common.h"

int main(int argc, char *argv[]) {
    int *p = (int*)malloc(sizeof(int));
    assert(p != NULL);
    printf("(%d) memory address of p: %p\n", getpid(), (void*)p);
    *p = 0;
    while (1) {
        Spin(1);
        *p = *p + 1;
        printf("(%d) p: %d\n", getpid(), *p);
    }
    free(p);  
    return 0;
}
```
我同时启动两个程序会发生什么呢？

我们会发现每个程序p指向的地址是相同的，但是每个程序的更新过程是独立的，彼此互不影响，这点是如何做到的呢？这里就引申出了这里的第二个概念：虚拟化内存，对于程序来说，它完全拥有自己的物理内存，但是实际上，物理内存是由操作系统管理的共享资源，每个进程访问自己的私有虚拟地址空间，os以某种方式映射到机器的物理内存上。

- 并发 

在并发编程中，我们一定尝试过多个递增线程来递增同一个对象，其实我们都知道这个结果是不可预测的，递增操作主要需要3条指令，将计数器的值从内存加载到寄存器，递增，将结果保存回内存由于这三步并不是原子操作，导致问题出现。具体细节会在后续进行讨论。

- 持久性

这一部分我的认知还是比较浅薄，概括能力也有限，书中大致意思为，对于数据来说，容易丢失，我们就需要硬件和软件持久地存储数据，但是操作系统又无法像cpu，内存一样为每个程序分配虚拟化的磁盘，相反，磁盘内容往往是共享的，这其中的问题会在后续进行讨论。

- 设计目标

（1）对于操作系统来说，一个最基本的目标就是建立一些抽象，让我们可以在写代码的时候不用考虑汇编，用汇编的时候不用考虑逻辑门，用逻辑门构建处理器的时候不用考虑晶体管。

（2）另外一个目标，是提供高性能

（3）其次是建立保护（隔离）保证安全性

最后，笔者简单聊了一些OS的历史，从早起OS -> 一代OS -> 多道程序时代 -> 摩登时代，这一大段还是很有意思的。


























